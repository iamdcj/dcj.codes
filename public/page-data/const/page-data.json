{"componentChunkName":"component---src-templates-blog-post-js","path":"/const/","result":{"data":{"site":{"siteMetadata":{"title":"Blog"}},"markdownRemark":{"id":"dceb6793-a471-528a-a96f-76bc95b36bb8","excerpt":"Variables ES2015 introduces two new variable statements for use in JavaScript applications; const The  statement is used to declare constant bindings in a…","html":"<h1>Variables</h1>\n<p>ES2015 introduces two new variable statements for use in JavaScript applications;</p>\n<h2>const</h2>\n<p>The <code class=\"language-text\">const</code> statement is used to declare constant bindings in a program.</p>\n<p>Constant declarations must be initialized; you cannot simply declare a <code class=\"language-text\">const</code>, it must be assigned a value on creation.</p>\n<p><code class=\"language-text\">const</code> declarations are affected by the <a href=\"../temporal-dead-zone\"><code class=\"language-text\">temporal dead zone</code></a></p>\n<h3><strong>Scope</strong></h3>\n<p><code class=\"language-text\">const</code> declarations can either be scoped globally, or local to its wrapping function or block.</p>\n<h3><strong>Global Scope</strong></h3>\n<p>Constants can be declared in the global lexical environment;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Dave = &quot;David&quot;;</code></pre></div>\n<p>However they do not become members of the <code class=\"language-text\">window</code> object;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(window.Dave); // undefined</code></pre></div>\n<h3><strong>Function Scope</strong></h3>\n<p>Any <code class=\"language-text\">const</code> declared in a function body are scoped to that function’s lexical environment, and its descendant lexical environments;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function test() {\n  const foo = &quot;bar&quot;\n  console.log(foo);\n\n  function test2() {\n    console.log(foo);\n  }\n\n  test2();\n}\ntest()\n\n// bar\n// bar</code></pre></div>\n<h3><strong>Block Scope</strong></h3>\n<p>Any <code class=\"language-text\">const</code> declared in a block are scoped to that particular block, and any child scopes;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  const Dave = &quot;David&quot;;\n}\n\nconsole.log(Dave) Uncaught ReferenceError: Dave is not defined</code></pre></div>\n<p>Unlike <code class=\"language-text\">var</code> declarations, which do leak outside of blocks, <code class=\"language-text\">const</code> declarations are bound to the wrapping function lexical environment, or if there is no wrapping function, the global lexical environment;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  var Dave = &quot;David&quot;;\n}\n\nconsole.log(Dave) // David\n\nfunction test() {\n  {\n    var foo = &quot;bar&quot;;\n  }\n  console.log(foo) // bar\n}\nconsole.log(foo) // Uncaught ReferenceError: foo is not defined</code></pre></div>\n<p>This provides a convenient way to shield bindings from the global scope, preventing global object pollution and potential binding collisions.</p>\n<h3><strong>Reassignment and Redeclaration</strong></h3>\n<p>Constants cannot be reassigned or redeclared.</p>\n<h3><strong>Reassignment</strong></h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const name = &quot;David&quot;;\n\nname = &quot;David Jones&quot;; // Uncaught TypeError: Assignment to constant variable.</code></pre></div>\n<h3><strong>Redeclaration</strong></h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const name = &quot;David&quot;;\n\nconst name = &quot;David Jones&quot;; // Uncaught SyntaxError: Identifier &#39;name&#39; has already been declared</code></pre></div>\n<h3><strong>Mutations</strong></h3>\n<p>Constants cannot be reassigned or redeclared, however if they are initialized with a composite value, the contents of the composite, e.g. an array or object, can be mutated.</p>\n<h3><strong>Objects</strong></h3>\n<p>The object can be modified in all the usual ways;</p>\n<p>Modify property values</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const testObj = {\n  name: &quot;David&quot;\n}\n\nconsole.log(testObj.name) // David\n\ntestObj.name = &quot;David Jones&quot;;\n\nconsole.log(testObj.name) // David Jones</code></pre></div>\n<p>Add new members</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">testObj.age = 32;\nconsole.log(testObj.age) // 32</code></pre></div>\n<p>Remove members</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">delete testObj.age;\nconsole.log(testObj.age) // undefined</code></pre></div>\n<h3><strong>Arrays</strong></h3>\n<p>Arrays can be modified in all the usual ways;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const testArray = [1, 2, 3, 4]\n\nconsole.log(testArray) // (4) [1, 2, 3, 4]\n\ntestArray.push(5);\n\nconsole.log(testArray) // (5) [1, 2, 3, 4, 5]</code></pre></div>\n<hr>\n<h5>References and Resources</h5>\n<ul>\n<li>[MDN](<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const%CB%9B%C2%B8\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const˛¸</a></li>\n</ul>\n<h1>let</h1>\n<p>The <code class=\"language-text\">let</code> statement is used to declare local bindings in a program, and are mainly used when a binding will likely be initialized and/or reassigned at a later point in the programs lifecycle.</p>\n<p><code class=\"language-text\">let</code> declarations are affected by the <a href=\"../temporal-dead-zone\"><code class=\"language-text\">temporal dead zone</code></a></p>\n<hr>\n<h2><strong>Reassignment and Redeclaration</strong></h2>\n<h3><strong>Reassignment</strong></h3>\n<p><code class=\"language-text\">let</code>s can be reassigned new values freely in a particular lexical environment;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let name = &quot;David&quot;;\nconsole.log(name); // David\n\nname = &quot;David Jones&quot;;\nconsole.log(name); // David Jones</code></pre></div>\n<p><code class=\"language-text\">let</code> declarations aren’t required to be initialized upon declaration; a <code class=\"language-text\">let</code> binding can be created without a value.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let chosenPerson;\nlet people = [&quot;David&quot;, &quot;Dave&quot;, &quot;Davy&quot;];\n\nchosenPerson = people.find(person =&gt; person.length &gt; 4);\n\nconsole.log(chosenPerson) // David</code></pre></div>\n<h3><strong>Redeclaration</strong></h3>\n<p><code class=\"language-text\">let</code>s cannot be declared more than once in a particular lexical environment;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let name = &quot;David&quot;;\nlet name = &quot;David Jones&quot;; // Uncaught SyntaxError: Identifier &#39;name&#39; has already been declared</code></pre></div>\n<h4>Shadowing</h4>\n<p>Bindings cannot be redeclared, but <code class=\"language-text\">let</code>s can be shadowed in nested/sibling blocks, i.e. you can declare a binding with the same identifier in nested/sibling blocks;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  let foo = &quot;bar&quot;;\n  {\n    let foo = &quot;baz&quot;;\n    console.log(foo) // baz\n\n    {\n      let foo = &quot;bazola&quot;;\n      console.log(foo) // bazola\n    }\n  }\n\n  {\n    let foo = &quot;quux&quot;;\n    console.log(foo) // quux\n  }\n  console.log(foo) // bar\n}</code></pre></div>\n<h2><strong>Scope</strong></h2>\n<p><code class=\"language-text\">let</code> declarations can either be scoped globally, or local to its wrapping function or block.</p>\n<h3><strong>Global Scope</strong></h3>\n<p><code class=\"language-text\">let</code>s can be declared in the global lexical environment;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let Dave = &quot;David&quot;;</code></pre></div>\n<p>However they do not become members of the <code class=\"language-text\">window</code> object;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(window.Dave); // undefined</code></pre></div>\n<h3><strong>Function Scope</strong></h3>\n<p>Any <code class=\"language-text\">let</code> declared in a function body are scoped to that function’s lexical environment, and its descendant lexical environments;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function test() {\n  let foo = &quot;bar&quot;\n  console.log(foo);\n\n  function test2() {\n    console.log(foo);\n\n  }\n\n  test2();\n}\ntest()\n\n// bar\n// bar</code></pre></div>\n<h3><strong>Block Scope</strong></h3>\n<p>Any <code class=\"language-text\">let</code> declared in a block are scope to that particular block;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  let Dave = &quot;David&quot;;\n}\n\nconsole.log(Dave) Uncaught ReferenceError: Dave is not defined</code></pre></div>\n<p>This provides a convenient way to create privacy in our programs by using <code class=\"language-text\">let</code> bindings, opposed to running an <code class=\"language-text\">IIFE</code> to shield the program bindings from the global lexical environment.</p>\n<h3>Differences to <code class=\"language-text\">var</code></h3>\n<p>When declared in the global lexical environment <code class=\"language-text\">let</code> statements will not be attached to the global object, whereas <code class=\"language-text\">var</code>s do become a member of the global object.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let foo = &quot;bar&quot;;\nconsole.log(window.foo); // undefined\n\nvar bar = &quot;foo&quot;;\nconsole.log(window.bar); // foo</code></pre></div>\n<p><code class=\"language-text\">var</code> bindings can be accessed outside of their wrapping block<code class=\"language-text\">{}</code>, <code class=\"language-text\">let</code>s are scoped to the block, and any child blocks/functions.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function foo() {\n\n  {\n    let baz = &quot;bar&quot;;\n    var bar = &quot;foo&quot;;\n  }\n  console.log(bar);\n  console.log(baz);\n\n}\nfoo();\n// foo\n// Uncaught ReferenceError: baz is not defined</code></pre></div>\n<p>This behaviour is useful when dealing with <code class=\"language-text\">for</code> loops;</p>\n<p>When using <code class=\"language-text\">var</code> the tracking variable is leaked into the parent lexical environment; <code class=\"language-text\">var</code>s are not scoped to the block.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for(var i = 0 i &lt; 10; i++) {\n  // ...do sumfink\n}\nconsole.log(i); // 10</code></pre></div>\n<p><code class=\"language-text\">let</code>s are block scoped, and the tracking variable does not leak into the parent lexical environment.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for(let k = 0; k &lt; 10; k++) {\n  // ...do sumfink\n}\nconsole.log(k); // Uncaught ReferenceError: k is not defined</code></pre></div>\n<p>A benefit of using <code class=\"language-text\">let</code> in a <code class=\"language-text\">for</code> loop is that the tracking variable is reassigned with every iteration; the binding does not leak into the parent scope.</p>\n<p>Using <code class=\"language-text\">var</code> in a loop when performing an async action;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for(var i = 0; i &lt; 10; i++) {\n  // mimic async\n  setTimeout(() =&gt; {\n    console.log(&quot;iteration: &quot;, i);\n  } , 1000)\n}\n// iteration:  10 (x10)</code></pre></div>\n<p>The log prints <code class=\"language-text\">10</code> ten times, which is a result of the variable leaking into the parent scope; the tracker(<code class=\"language-text\">i</code>) is not re-initialized on each iteration, instead the loop is simply updating a static binding in the parent scope; the loop has finished iterating by the time the timeout performs the log, and the value of the tracker is always <code class=\"language-text\">10</code> as a result.</p>\n<p>If the idea is to use the current iteration number to do a particular thing, once the timeout is complete, there are a couple of ways to ‘fix’ this;</p>\n<p><strong>1. Stick with <code class=\"language-text\">var</code>, use an <code class=\"language-text\">IIFE</code></strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for(var i = 0; i &lt; 10; i++) {\n  (function(i) {\n    // mimic async\n    setTimeout(() =&gt; {\n      console.log(&quot;iteration: &quot;, i);\n    } , 1000)\n  })(i)\n}\n\n// iteration: 0\n...\n// iteration: 9</code></pre></div>\n<p>The <code class=\"language-text\">IIFE</code> takes the tracker binding as a parameter, thus capturing the current iteration number for each iteration, allowing the timeout to print the expected value.</p>\n<p><strong>2. Use <code class=\"language-text\">let</code> instead of <code class=\"language-text\">var</code></strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for(let i = 0; i &lt; 10; i++) {\n  // mimic async\n  setTimeout(() =&gt; {\n    console.log(&quot;iteration: &quot;, i);\n  } , 1000)\n}\n// iteration: 0\n...\n// iteration: 9</code></pre></div>\n<p>The tracker(<code class=\"language-text\">i</code>) is reassigned with each iteration, thus the value printed in after the timeout is always that of the current iteration.</p>\n<hr>\n<h5>References and Resources</h5>\n<ul>\n<li>[MDN](<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let%CB%9B%C2%B8\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let˛¸</a></li>\n</ul>\n<h3><strong>Semantics</strong></h3>\n<p><code class=\"language-text\">const</code> and <code class=\"language-text\">let</code> possess intrinsic semantic value when authoring applications; they provide clarity on what is likely to happen/not happen with the variable declarations, and the values inside of them;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const foo = &quot;bar&quot;</code></pre></div>\n<p><code class=\"language-text\">foo</code> has a value which will not change later in the application’s lifecycle.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let bar</code></pre></div>\n<p><code class=\"language-text\">bar</code> does not yet hold a value, but will later in the application’s lifecycle.</p>\n<h3><strong>Behaviour</strong></h3>\n<p>The semantics are backed-up by additional behaviour; <code class=\"language-text\">const</code> declarations cannot be reassigned, whereas <code class=\"language-text\">let</code> declarations signify the intent to reassign.</p>\n<h3><strong>Scoping Rules</strong></h3>\n<p>Both <code class=\"language-text\">const</code> and <code class=\"language-text\">let</code> introduce block scoped bindings to JavaScript applications.</p>\n<hr>\n<h4>Does <code class=\"language-text\">var</code> have a future?</h4>\n<p>It depends on your stance, some use <code class=\"language-text\">var</code> for variables shared across many scopes, others simply don’t bother with it at all. <strong>I don’t use it, I don’t see a good reason to.</strong></p>","frontmatter":{"title":"ES6 101 - using the const statement","date":"August 19, 2019","description":"How and when to use the const statement"}},"previous":null,"next":{"fields":{"slug":"/let/"},"frontmatter":{"title":"ES6 101 - using the let statement"}}},"pageContext":{"id":"dceb6793-a471-528a-a96f-76bc95b36bb8","previousPostId":null,"nextPostId":"ba56c288-039f-5d18-bb0e-864471e5188b"}},"staticQueryHashes":["2841359383","3257411868"]}
{"componentChunkName":"component---src-templates-blog-post-js","path":"/let/","result":{"data":{"site":{"siteMetadata":{"title":"Blog"}},"markdownRemark":{"id":"ba56c288-039f-5d18-bb0e-864471e5188b","excerpt":"ES2015 introduces two new variable statements for use in JavaScript applications:  and . In today’s entry I will be focusing on the  statement and how, why, and…","html":"<p>ES2015 introduces two new variable statements for use in JavaScript applications: <code class=\"language-text\">const</code> and <code class=\"language-text\">let</code>. In today’s entry I will be focusing on the <code class=\"language-text\">let</code> statement and how, why, and when to use it.</p>\n<p>The <code class=\"language-text\">let</code> statement is used to declare local bindings in a program, and are mainly used when a binding will likely be initialized and/or reassigned at a later point in the programs lifecycle.</p>\n<p><code class=\"language-text\">let</code> declarations are affected by the <a href=\"/temporal-dead-zone\"><code class=\"language-text\">temporal dead zone</code></a></p>\n<hr>\n<h3><strong>Reassignment and Redeclaration</strong></h3>\n<h4><strong>Reassignment</strong></h4>\n<p><code class=\"language-text\">let</code>s can be reassigned new values freely in a particular lexical environment;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let name = &quot;David&quot;;\nconsole.log(name); // David\n\nname = &quot;David Jones&quot;;\nconsole.log(name); // David Jones</code></pre></div>\n<p><code class=\"language-text\">let</code> declarations aren’t required to be initialized upon declaration; a <code class=\"language-text\">let</code> binding can be created without a value.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let chosenPerson;\nlet people = [&quot;David&quot;, &quot;Dave&quot;, &quot;Davy&quot;];\n\nchosenPerson = people.find(person =&gt; person.length &gt; 4);\n\nconsole.log(chosenPerson) // David</code></pre></div>\n<h4><strong>Redeclaration</strong></h4>\n<p><code class=\"language-text\">let</code>s cannot be declared more than once in a particular lexical environment;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let name = &quot;David&quot;;\nlet name = &quot;David Jones&quot;; // Uncaught SyntaxError: Identifier &#39;name&#39; has already been declared</code></pre></div>\n<h6>Shadowing</h6>\n<p>Bindings cannot be redeclared, but <code class=\"language-text\">let</code>s can be shadowed in nested/sibling blocks, i.e. you can declare a binding with the same identifier in nested/sibling blocks;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  let foo = &quot;bar&quot;;\n  {\n    let foo = &quot;baz&quot;;\n    console.log(foo) // baz\n\n    {\n      let foo = &quot;bazola&quot;;\n      console.log(foo) // bazola\n    }\n  }\n\n  {\n    let foo = &quot;quux&quot;;\n    console.log(foo) // quux\n  }\n  console.log(foo) // bar\n}</code></pre></div>\n<h3><strong>Scope</strong></h3>\n<p><code class=\"language-text\">let</code> declarations can either be scoped globally, or local to its wrapping function or block.</p>\n<h4><strong>Global Scope</strong></h4>\n<p><code class=\"language-text\">let</code>s can be declared in the global lexical environment;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let Dave = &quot;David&quot;;</code></pre></div>\n<p>However they do not become members of the <code class=\"language-text\">window</code> object;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(window.Dave); // undefined</code></pre></div>\n<h4><strong>Function Scope</strong></h4>\n<p>Any <code class=\"language-text\">let</code> declared in a function body are scoped to that function’s lexical environment, and its descendant lexical environments;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function test() {\n  let foo = &quot;bar&quot;\n  console.log(foo);\n\n  function test2() {\n    console.log(foo);\n\n  }\n\n  test2();\n}\ntest()\n\n// bar\n// bar</code></pre></div>\n<h4><strong>Block Scope</strong></h4>\n<p>Any <code class=\"language-text\">let</code> declared in a block are scope to that particular block;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  let Dave = &quot;David&quot;;\n}\n\nconsole.log(Dave) Uncaught ReferenceError: Dave is not defined</code></pre></div>\n<p>This provides a convenient way to create privacy in our programs by using <code class=\"language-text\">let</code> bindings, opposed to running an <code class=\"language-text\">IIFE</code> to shield the program bindings from the global lexical environment.</p>\n<h4>Differences to <code class=\"language-text\">var</code></h4>\n<p>When declared in the global lexical environment <code class=\"language-text\">let</code> statements will not be attached to the global object, whereas <code class=\"language-text\">var</code>s do become a member of the global object.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let foo = &quot;bar&quot;;\nconsole.log(window.foo); // undefined\n\nvar bar = &quot;foo&quot;;\nconsole.log(window.bar); // foo</code></pre></div>\n<p><code class=\"language-text\">var</code> bindings can be accessed outside of their wrapping block<code class=\"language-text\">{}</code>, <code class=\"language-text\">let</code>s are scoped to the block, and any child blocks/functions.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function foo() {\n\n  {\n    let baz = &quot;bar&quot;;\n    var bar = &quot;foo&quot;;\n  }\n  console.log(bar);\n  console.log(baz);\n\n}\nfoo();\n// foo\n// Uncaught ReferenceError: baz is not defined</code></pre></div>\n<p>This behaviour is useful when dealing with <code class=\"language-text\">for</code> loops;</p>\n<p>When using <code class=\"language-text\">var</code> the tracking variable is leaked into the parent lexical environment; <code class=\"language-text\">var</code>s are not scoped to the block.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for(var i = 0 i &lt; 10; i++) {\n  // ...do sumfink\n}\nconsole.log(i); // 10</code></pre></div>\n<p><code class=\"language-text\">let</code>s are block scoped, and the tracking variable does not leak into the parent lexical environment.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for(let k = 0; k &lt; 10; k++) {\n  // ...do sumfink\n}\nconsole.log(k); // Uncaught ReferenceError: k is not defined</code></pre></div>\n<p>A benefit of using <code class=\"language-text\">let</code> in a <code class=\"language-text\">for</code> loop is that the tracking variable is reassigned with every iteration; the binding does not leak into the parent scope.</p>\n<p>Using <code class=\"language-text\">var</code> in a loop when performing an async action;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for(var i = 0; i &lt; 10; i++) {\n  // mimic async\n  setTimeout(() =&gt; {\n    console.log(&quot;iteration: &quot;, i);\n  } , 1000)\n}\n// iteration:  10 (x10)</code></pre></div>\n<p>The log prints <code class=\"language-text\">10</code> ten times, which is a result of the variable leaking into the parent scope; the tracker(<code class=\"language-text\">i</code>) is not re-initialized on each iteration, instead the loop is simply updating a static binding in the parent scope; the loop has finished iterating by the time the timeout performs the log, and the value of the tracker is always <code class=\"language-text\">10</code> as a result.</p>\n<p>If the idea is to use the current iteration number to do a particular thing, once the timeout is complete, there are a couple of ways to ‘fix’ this;</p>\n<p><strong>1. Stick with <code class=\"language-text\">var</code>, use an <code class=\"language-text\">IIFE</code></strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for(var i = 0; i &lt; 10; i++) {\n  (function(i) {\n    // mimic async\n    setTimeout(() =&gt; {\n      console.log(&quot;iteration: &quot;, i);\n    } , 1000)\n  })(i)\n}\n\n// iteration: 0\n...\n// iteration: 9</code></pre></div>\n<p>The <code class=\"language-text\">IIFE</code> takes the tracker binding as a parameter, thus capturing the current iteration number for each iteration, allowing the timeout to print the expected value.</p>\n<p><strong>2. Use <code class=\"language-text\">let</code> instead of <code class=\"language-text\">var</code></strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for(let i = 0; i &lt; 10; i++) {\n  // mimic async\n  setTimeout(() =&gt; {\n    console.log(&quot;iteration: &quot;, i);\n  } , 1000)\n}\n// iteration: 0\n...\n// iteration: 9</code></pre></div>\n<p>The tracker(<code class=\"language-text\">i</code>) is reassigned with each iteration, thus the value printed in after the timeout is always that of the current iteration.</p>\n<h4><strong>Semantics</strong></h4>\n<p><code class=\"language-text\">const</code> and <code class=\"language-text\">let</code> possess intrinsic semantic value when authoring applications; they provide clarity on what is likely to happen/not happen with the variable declarations, and the values inside of them;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const foo = &quot;bar&quot;</code></pre></div>\n<p><code class=\"language-text\">foo</code> has a value which will not change later in the application’s lifecycle.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let bar</code></pre></div>\n<p><code class=\"language-text\">bar</code> does not yet hold a value, but will later in the application’s lifecycle.</p>\n<h4><strong>Behaviour</strong></h4>\n<p>The semantics are backed-up by additional behaviour; <code class=\"language-text\">const</code> declarations cannot be reassigned, whereas <code class=\"language-text\">let</code> declarations signify the intent to reassign.</p>\n<hr>\n<h5>Does <code class=\"language-text\">var</code> have a future?</h5>\n<p>It depends on your stance, some use var for variables shared across many scopes, others simply don’t bother with it at all. I don’t use it, I don’t see a good reason to, but I’m not against it being used in a new build if it was made clear it was being utilized.</p>","frontmatter":{"title":"ES6 101 - using the let statement","date":"August 20, 2019","description":"How and when let statement"}},"previous":{"fields":{"slug":"/const/"},"frontmatter":{"title":"ES6 101 - using the const statement"}},"next":{"fields":{"slug":"/temporal-dead-zone/"},"frontmatter":{"title":"ES6 101 - The Temporal Dead Zone"}}},"pageContext":{"id":"ba56c288-039f-5d18-bb0e-864471e5188b","previousPostId":"dceb6793-a471-528a-a96f-76bc95b36bb8","nextPostId":"ddabf1b5-6fed-573d-a5a8-3d10ec83fecc"}},"staticQueryHashes":["2841359383","3257411868"]}